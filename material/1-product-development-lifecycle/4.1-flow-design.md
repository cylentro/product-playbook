# Flow Design Deep-Dive

In Module 4, we move from high-level concepts to concrete blueprints. To ensure no gaps exist between the user experience and the system's execution, the squad must document three distinct types of flows for every feature.

## 1. The User Flow (The UX Perspective)

Goal: Map the visual journey and interaction points of the user.

The User Flow is a step-by-step visualization of the screens and actions a user takes to complete a task. Unlike a simple "Happy Path," a professional User Flow must account for the "messy" reality of app usage.

* Happy Path: The ideal sequence of events (e.g., User opens AMA → Clicks Check Rates → Inputs destination → Sees price).
* Circular Paths: What happens when a user hits "Back," "Cancel," or tries to edit a previous field?
* Error & Empty States: What does the user see if there are no search results or if their internet disconnects mid-transaction?
* Case Example (Anteraja Pro): * Start: User opens Dashboard.
  * Action: Taps on the Pro Progress Bar.
  * Screen: Detailed view of current order count vs. the 60-order goal.
  * Decision: User clicks "Claim Reward" (if eligible) or "Ship More" (if not).

## 2. The Business Flow (The Logic Perspective)

Goal: Document the rules, decision gates, and "If/Then" logic that govern the product.

The Business Flow strips away the UI and focuses entirely on the logic. This is the "brain" of the feature. It ensures that the business requirements we defined in Ideation (Module 3) are actually enforced.

* Decision Gates: Diamond-shaped nodes in a flowchart where a choice is made (e.g., "Is user a Retail or B2B segment?").
* Status Changes: Triggers that move a user from one state to another (e.g., "Update user status to PRO if order count >= 60 in Q1").
* Calculations: Specific formulas used (e.g., "Insurance Premium = 0.2% of Declared Value").
* Case Example (Shipping Insurance):
  * Rule 1: If item value < Rp500,000, insurance is optional.
  * Rule 2: If item value > Rp1,000,000, show a "High Value" warning toast.
  * Rule 3: If insurance vendor A is offline, route the request to vendor B (Aggregator Logic).

## 3. Application/System Flow (The Tech Perspective)

Goal: Map the technical "handshake" between the frontend, backend, and third-party services.

This is the bridge to Engineering. It documents how data moves between systems. Without this, a PM might design a feature that is impossible to build given our current API infrastructure.

* API Handshakes: Which endpoint is called when a button is clicked? (e.g., POST /v1/insurance/calculate).
* Database Triggers: What data is being saved or updated in the background?
* Third-Party Integrations: The flow of data to external partners (e.g., Biza CSV upload → Validation Service → Address Master Data → Response).
* Case Example (Shipping Insurance Aggregator):
  1. Request: AMA App sends ItemValue and Category to our Insurance Service.
  1. Logic: Insurance Service checks our "Self-Insurance" rules vs. "Vendor" rules.
  1. External Call: Service calls the Insurance Vendor API with a payload.
  1. Response: Vendor returns a policy ID; our system saves it and displays "Success" to the user.

## Why we need all three

* Missing User Flow? The app is functional but confusing and frustrating to use.
* Missing Business Flow? The app looks great but allows users to "game" the system or break business rules.
* Missing System Flow? The design is beautiful and logical, but the developers can't build it because the data doesn't exist.
